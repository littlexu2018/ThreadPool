* 线程池——学习什么首先是要讲他的优点
* 1.为什么使用线程池
  * 服务器应用中经常大量的请求，任务数量多而请求的数量是庞大的。
  
  * 为每个请求创建一个新线程的开销很大；
  为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多。
  就是请求执行很短，但是创建线程和销毁线程非常费时间。
  
  * 除了创建和销毁线程的开销之外，活动的线程也消耗系统资源。在一个 JVM 里创建太多的线程可能会导致系统由于过度消耗内存而用完内存或“切换过度”。
  为了防止资源不足，服务器应用程序需要一些办法来限制任何给定时刻处理的请求数目。
  
  * 线程池为线程生命周期开销问题和资源不足问题提供了解决方案。
  通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。
  其好处是，`因为在请求到达时线程已经存在`，所以无意中也消除了线程创建所带来的延迟。
  这样，`就可以立即为请求服务，使应用程序响应更快`。
  而且，通过适当地调整线程池中的线程数目，
  也就是`当请求的数目超过某个阈值时`，`就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止`，从而可以防止资源不足。

 * 2.使用线程池的缺点
    * 虽然线程池是构建多线程应用程序的强大机制，但使用它并不是没有风险的。用线程池构建的应用程序容易遭受任何其它多线程应用程序容易遭受的所有并发风险，诸如同步错误和死锁，它还容易遭受特定于线程池的少数其它风险，诸如与池有关的死锁、资源不足和线程泄漏。
    * 2.1 死锁
        * 任何多线程应用程序都有死锁风险。当一组进程或线程中的每一个都在等待一个只有该组中另一个进程才能引起的事件时，我们就说这组进程或线程 死锁了。死锁的最简单情形是：线程 A 持有对象 X 的独占锁，并且在等待对象 Y 的锁，而线程 B 持有对象 Y 的独占锁，却在等待对象 X 的锁。除非有某种方法来打破对锁的等待（Java 锁定不支持这种方法），否则死锁的线程将永远等下去。
        * 虽然任何多线程程序中都有死锁的风险，`但线程池却引入了另一种死锁可能`，在那种情况下，所有池线程都在执行已阻塞的等待队列中另一任务的执行结果的任务，但这一任务却因为没有未被占用的线程而不能运行。当线程池被用来实现涉及许多交互对象的模拟，被模拟的对象可以相互发送查询，这些查询接下来作为排队的任务执行，查询对象又同步等待着响应时，会发生这种情况。